#!/usr/bin/env bash

#
# dex
#

main(){

  __cmd="main"
  __entrypoint="$0 $@"
  __build="f9181c3"
  __version="master"

  # DEX_BIN_DIR: location where dex installs : /usr/local/bin
  # DEX_BIN_PREFIX: prefix of dexecutabls : d
  # DEX_HOME: dex workspace : ~/.dex
  # DEX_NAMESPACE: prefix used when tagging image builds : dex/v1
  # DEX_NETWORK: enables network fetching : true
  # DEX_RUNTIME: runtime api version: v1

  DEX_VARS=( DEX_BIN_DIR DEX_BIN_PREFIX DEX_HOME DEX_NETWORK DEX_RUNTIME DEX_NAMESPACE )
  dex-vars-init ${DEX_VARS[@]}

  if [ $# -eq 0 ]; then
    display_help 2
  else
    while [ $# -ne 0 ]; do
      case $1 in
        image|install|source|run|uninstall|update|vars)
          __cmd=$1 ; shift ; main_$__cmd "$@" ;;

        ping)             shift ; echo "${@:-pong}" ; exit 0 ;;
        help)             __cmd=${2:-$__cmd} ; display_help ;;
        runfunc)          shift ; runfunc "$@" ; exit $? ;;
        -h|--help)        display_help ;;
        -v|--version)     log "Dex version $__version build $__build" ;;
        -*)               unrecognized_flag "$1" ;;
        *)                unrecognized_arg "$1" ;;
      esac
      shift
    done
  fi

  exit $?
}

#
# lib.d/display_help.sh for dex -*- shell-script -*-
#

display_help() {
  [ "$(type -t display_help_$__cmd)" = "function" ] || error \
    "missing helpfile for $__cmd" "is $__cmd a valid command?"

  display_help_$__cmd
  [ -z "$1" ] && exit 0
  exit $1
}
#
# lib.d/display_help.sh for dex -*- shell-script -*-
#

display_help_image(){
  cat <<-EOF

Piping hot docker executables to your door.

images don't make themselves, dex will.

Usage: dex image <command> [options]

  # build the macos version of sed from any repository (first found)
  dex build sed:macos

  # build 'sed' from the "extras" repository
  dex image build extras/sed

  # build all images from the "extras" repository
  dex image build extras/*

Commands:

  build <imgstr>*        Builds an image. Optionally slash-pass repository.
  rm <imgstr>*           Remove an image. Optionally slash-pass repository.
  ls                     Lists images dex has built.

* <imgstr> is a multi-form string defined as "[source/]<image[*]>[:tag]" and is
  used to lookup image(s), optionally filtering by source name and/or tag

Options:

  -h|--help|help        Display help

  -a|--all              Return images from all namespaces (all api versions,
                        all installed states) when searching for images

  -f|--force            When removing, persisted runs will be deleted.
                        When building, ignore API version check.

  -q|--quiet            When listing images, only show numeric IDS


EOF
}
#
# lib.d/display_help.sh for dex -*- shell-script -*-
#

display_help_install(){
  cat <<-EOF
Piping hot docker executables to your door.

Installing dexecutables builds their image and copies their runtime script to
\$DEX_BIN_DIR (usually /usr/local/bin). The script is prefixed using
\$DEX_BIN_PREFIX (usually 'd'), so installing 'sed' creates /usr/local/bin/dsed.

You may 'globally' install, which will create a symlink to the dexecutable
without a prefix, so /usr/local/bin/sed points to /usr/local/bin/dsed and
can be executed as plain old 'sed' as if it were installed locally.

Be sure your PATH prioritizes \$DEX_BIN_DIR if you want to run dexecutable
versions instead of OS installed ones.

Installed executables
  * launch faster than 'dex run <image>', as they avoid the repository search.
  * always execute the same [version] of the image built when installed --
    whereas 'dex run <image>' attempts to run the latest after a repository pull

Usage: dex install [options] <imgstr>*

  # Install a dexecutable (creates 'dsed' and 'dsed-macos' in /usr/local/bin)
  dex install sed
  dex install sed:macos

  # Install a dexecutable from a specific source repository
  dex install extras/sed

  # Globally install a dexecutable (creates 'sed' in /usr/local/bin)
  dex install --global sed:macos

* <imgstr> is a multi-form string defined as "[source/]<image[*]>[:tag]" and is
  used to lookup image(s), optionally filtering by source name and/or tag

Options:

  -h|--help|help        Display help
  -p|--pull             Refresh checkout(s) before building+installing
  -g|--global           Globally install the dexecutable
  -f|--force            Overwrite target(s) if they already exist.

EOF
}
#
# lib.d/display_help.sh for dex -*- shell-script -*-
#

display_help_main(){
  cat <<-EOF

Piping hot docker executables to your door.

Usage: dex <command> [options]

  dex run --pull sed
  dex run sed s/foo/bar/ <(echo 'foo')
  dex run sed:macos -h

Commands:

  help <command>                Display help for a particular command
  image <command> [options]     Build and maintain images
  install <imgstr>* [options]   Install a dexecutable to \$DEX_BIN_DIR
  source <command> [options]    Manage source repositories
  run <imgstr>* [options]       Execute an image
  uninstall <imgstr>* [options] Uninstall a dexecutable
  vars [options]                print configuration variables (and/or defaults)

* <imgstr> is a multi-form string defined as "[source/]<image[*]>[:tag]" and is
  used to lookup image(s), optionally filtering by source name and/or tag

Options:

  -h|--help                    Display help

EOF
}
#
# lib.d/display_help.sh for dex -*- shell-script -*-
#

display_help_run(){
  cat <<-EOF

Piping hot docker executables to your door.

'dex run <imagestr>' executes images as if the contained application was locally
installed. We call these images "docker executables" or "dexecutables".

Images are built from Dockerfiles kept in "source repositories" in the
\$DEX_HOME/sources.list file and managed by the 'dex source' command.

Dex run searches images from source checkouts matching <imgstr> and executes the
first found. Limit searching by slash-passing a source and/or tag. Using
'dex install' will bypass it entirely.

'dex run' will automatically build the matching image from its Dockerfile on
first run -- introducing a delay. Use 'dex image' to build and maintain images.

Usage: dex run <imgstr>* [options]

  # Run a dexecutable (below examples run sed)
  dex run sed
  echo 'foo' | dex run sed s/foo/bar/
  dex run sed s/foo/bar/ <(echo 'foo')

  # Run a tagged version of a dexecutable (below maps to sed/Dockerfile.macos)
  dex run sed:macos -h

  # Run a dexecutable from a particular source repository
  dex run extra/gitk

* <imgstr> is a multi-form string defined as "[source/]<image[*]>[:tag]" and is
  used to lookup image(s), optionally filtering by source name and/or tag

Options:

  -h|--help             Display help
  -b|--build            Always build the image before executing
  -p|--pull             Refresh checkout(s) before executing, implies --build
  --persist             Persist the container after it exits

EOF
}
#
# lib.d/display_help.sh for dex -*- shell-script -*-
#

display_help_source(){
  cat <<-EOF

Piping hot docker executables to your door.

"dexecutables" are images built and executed from Dockerfiles contained within
git "source repositories" defined in \$DEX_HOME/sources.list.

The sources.list file lists repositories, one per line, in space-delimited
"<name> <url>" format. "name" must be alphanumeric and "url" must be the
repository URL (remote or a local path). E.g.

  reponame git@github.com:User/reponame.git
  reponame /path/to/reponame

Repositories are cloned under \$DEX_HOME/checkouts. If a local path is used,
a shared clone will be made.

Removing or adding repositories will not effect built images, allowing
installed dexecutables to function as normal. Use the "dex image" command to
manage images built from sources.

Usage: dex source <command> [options]

  # Add an additional dexecutable source repository named "extras"
  dex source add extras git@github.com:dockerland/dex-dockerfiles-extra.git

Commands:

  add <name> <url>       Add (and pulls) a dexecutable source repository.
  pull [sourcestr]       Pull (refresh) sources, optionally matching name || url
  rm <sourcestr>         Remove source repository matching name || url.
  ls                     List available source repositories

* <sourcestr> is a multi-form string written as <name|url|'*'> and is used to
  lookup source(s) by name, url, or wildcard ('*') to match all.

Options:

  -h|--help|help        Display help
  -f|--force            When removing or pulling, discard working copy changes
                        When adding, first remove any matching name

EOF
}
#
# lib.d/display_help.sh for dex -*- shell-script -*-
#

display_help_uninstall(){
  cat <<-EOF
Piping hot docker executables to your door.

Leave not a trace

Uninstalling <image> removes its prefixed and global (non-prefixed) counterpart
as well as removing its image and, if forced, any persisted runs.

Usage: dex uninstall <image> [options]

  # remove sed (/usr/local/bin/dsed) and its global counterpart
  dex uninstall sed

Options:

  -h|--help|help        Display help
  -f|--force            force remove built image and any persisted runs.
  -p|--prefix           Prefix to use when (un)installing dexecutables
                        (defaults to \$DEX_BIN_PREFIX:-'d')
  -t|--target           Target directory for (un)installations
                        (defaults \$DEX_BIN_DIR:-'/usr/local/bin')

EOF
}
#
# lib.d/display_help.sh for dex -*- shell-script -*-
#

display_help_vars(){
  cat <<-EOF

Piping hot docker executables to your door.

Variable Defaults:
  DEX_HOME: ~/.dex
  DEX_BIN_DIR: '/usr/local/bin'
  DEX_BIN_PREFIX: 'd'
  DEX_NETWORK: true
  DEX_RUNTIME: v1
  DEX_NAMESPACE: dex/$DEX_RUNTIME

Usage: dex vars [var] [options]

  # print all dex configuration vars and their resolved value
  dex vars all

  # print specific vars
  dex vars DEX_BIN_DIR DEX_BIN_PREFIX

  # print variable defaults (evalute output to restore)
  dex vars -d all
  dex vars -d DEX_HOME

Options:

  -h|--help|help        Display help
  -d|--defaults         evaluate output to set/restore defaults.

EOF
}

# dex-detect-imgstr accepts <[repo/]image|*> and sets
#  __source_match (source checkout, e.g. 'core', '*')
#  __image_match (source checkout image name, e.g. 'alpine', '*')
#  __image_tag (source checkout image tag, e.g. 'latest')
dex-detect-imgstr(){
  local vars=( __source_match __image_match __image_tag )
  local debug=${2:-false}

  for var in ${vars[@]}; do
    eval $var=
  done

  [ -z "$1" ] && return 1

  IFS='/'
  read -r source imagestr <<< "$1"
  unset IFS

  if [ -z "$imagestr" ]; then
    __source_match="*"
    __image_match="$1"
  else
    __source_match="$source"
    __image_match="$imagestr"

    if [ ! -d $DEX_HOME/checkouts/$__source_match ]; then
      log "warning, $source is not checked out."
    fi
  fi

  IFS=':'
  read -r image tag <<< "$__image_match"
  unset IFS

  if [ -z "$tag" ]; then
    __image_tag="latest"
  else
    __image_match="$image"
    __image_tag="$tag"
  fi

  # if $2 is true, echo lines for evaluation
  $debug && dex-vars-print ${vars[@]}
  return 0
}


# dex-detect-sourcestr sets __sources (array of sources.list matches in "name url" format)
# usage: dex-detect-sourcestr <sourcestr|*>
#    ex: dex-detect-sourcestr core => 0: __sources=( "core git@github.com:dockerland/dex-dockerfiles-core.git" )
#    ex: dex-detect-sourcestr git@github.com:dockerland/dex-dockerfiles-core.git => 0: __sources=( "core git@github.com:dockerland/dex-dockerfiles-core.git" )
#    ex: dex-detect-sourcestr * => 0: __sources=( "core git@github.com:dockerland/dex-dockerfiles-core.git" "extra:git@github.com dockerland/dex-dockerfiles-extra.git" )
#    ex: dex-detect-sourcestr * => 1: __sources=( )
dex-detect-sourcestr(){
  __sources=()
  local retval=1

  [ -e $DEX_HOME/sources.list ] || error_noent "missing $DEX_HOME/sources.list"

  while read name url junk ; do

    # skip blank, malformed, or comment lines
    if [ -z "$name" ] || [ -z "$url" ] || [[ $name = \#* ]]; then
      continue
    fi

    if [ "$1" = "*" ] || [ "$name" = "$1" ] ||  [ "$url" = "$1" ]; then
      __sources+=( "$name $url" )
      retval=0
    fi
  done < $DEX_HOME/sources.list

  return $retval
}


# dex-image-build expects __imsgstr and builds images(s) from detected sources.
#  accepts [optional] namespace, sets __built_images array.
#
# usage: dex-image-build [namespace]
#    ex: __imgstr="alpine" ; dex-image-build => 1: __built_images=( "dex/v1/alpine:latest" )
#    ex: __imgstr="alpine" ; dex-image-build dex/v1-install => 1: __built_images=( "dex/v1-install/alpine:latest" )
#    ex: __imgstr="invalid-image-name" ; dex-image-build => 1: __built_images=( )

dex-image-build(){
  # when installing, we prefix with "dex/$DEX_RUNTIME-install"
  local namespace=${1:-$DEX_NAMESPACE}
  __built_images=()

  [ -z "$__imgstr" ] && error_exception \
    "image-build requires an [repository/]<image>[:tag] imgstr"

  dex-detect-imgstr $__imgstr || error "lookup failed to parse $__imgstr"


  log "* building $__source_match/$__image_match images..."

  for repo_dir in $(ls -d $DEX_HOME/checkouts/$__source_match 2>/dev/null); do
    for image_dir in $(ls -d $repo_dir/dex-images/$__image_match 2>/dev/null); do
      if [ "$__image_tag" = "latest" ]; then
        dockerfile="Dockerfile"
      else
        dockerfile="Dockerfile-$__image_tag"
      fi
      [ -e $image_dir/$dockerfile ] || continue

      local image=$(basename $image_dir)
      local source=$(basename $repo_dir)
      local tag="$namespace/$image:$__image_tag"
      local random=$(LC_CTYPE=C tr -dc 'a-zA-Z0-9-_' < /dev/urandom | head -c10)
      local cachebust=
      local pull=

      log "- building $tag"
      (
        set -e
        cd $image_dir

        # add cachebusting argument if requested/used in Dockerfile
        grep -q "^ARG DEXBUILD_NOCACHE" $dockerfile &&  \
          cachebust="--build-arg DEXBUILD_NOCACHE=$random"

        $__pull_flag && \
          pull="--pull"

        __local_docker build -t $tag $cachebust $pull \
          --label=org.dockerland.dex.build-api=$DEX_RUNTIME \
          --label=org.dockerland.dex.build-imgstr="$__imgstr" \
          --label=org.dockerland.dex.build-tag="$__image_tag" \
          --label=org.dockerland.dex.image=$image \
          --label=org.dockerland.dex.namespace=$namespace \
          --label=org.dockerland.dex.source=$source \
          -f $dockerfile .
      ) && __built_images+=( "$tag" )

    done
  done

  if [ ${#__built_images[@]} -gt 0 ]; then
    for __image in ${__built_images[@]}; do
      # force re-create "build" container
      dex-image-build-container $__image true &>/dev/null
      log "+ built $__image"
    done
    return 0
  else
    return 1
  fi
}


dex-image-ls(){
  local namespace=${1:-$DEX_NAMESPACE}
  if $__skip_namespace; then
    local filters="--filter=label=org.dockerland.dex.namespace"
  else
    local filters="--filter=label=org.dockerland.dex.namespace=$namespace"
  fi

  if [ ! -z "$__imgstr" ]; then
    dex-detect-imgstr $__imgstr

    [ ! "$__source_match" = "*" ] && \
      filters="$filters --filter=label=org.dockerland.dex.source=$__source_match"

    #@TODO support wildcards in image_match by switching to repository:tag form
    [ ! "$__image_match" = "*" ] && \
      filters="$filters --filter=label=org.dockerland.dex.image=$__image_match"

    [ ! "$__image_tag" = "*" ] && \
      filters="$filters --filter=label=org.dockerland.dex.build-tag=$__image_tag"
  fi

  __local_docker images $QUIET_FLAG $filters
}


dex-image-rm(){
  local namespace=${1:-$DEX_NAMESPACE}
  local removed_image=false
  local force_flag=
  $__force_flag && force_flag="--force"

  [ -z "$__imgstr" ] && error_exception \
    "image-rm requires an [repository/]<image>[:tag] imgstr"

  QUIET_FLAG="-q"
  for image in $(dex-image-ls $namespace); do
    # remove any 'build' containers
    for container in $(__local_docker ps -aq --filter "ancestor=$image" --filter "name=_dexbuild"); do
      __local_docker rm --force $container &>/dev/null
    done

    # remove image
    __local_docker rmi $force_flag $image && removed_image=true
  done

  $removed_image && {
    log "removed $__source_match/$__image_match"
    exit 0
  }

  error "failed to remove any images matching $__imgstr"
}

# dex-image-build-container - ensure a container is accessible for an image
#  expects image name, prints container sha or returns 1 if no missing.
#
#  build containers are useful for pulling files out of a container during
#  runtime, e.g. to augment /etc/passwd. prints the sha of build container.
#
# usage: dex-image-build-container <image name> [force-recreate]
dex-image-build-container(){
  local name=$(docker_safe_name "$1" "dexbuild")
  local recreate=${2:-false}
  __image_container=
  (
    exec &>/dev/null
    $recreate && __local_docker rm --force $name
    __local_docker inspect --type container $name || {
      __local_docker run --entrypoint=false --name=$name $1
    }
  )
  __local_docker inspect -f "{{ .Id }}" --type container $name || return 1
}
#
# lib.d/dex-install.sh for dex -*- shell-script -*-
#

dex-install(){
  [ -z "$__imgstr" ] && error_exception \
    "dex-install requires an [repository/]<image>[:tag] imgstr"

  [ -d "$DEX_BIN_DIR" ] || error_noent "\$DEX_BIN_DIR $DEX_BIN_DIR is missing"
  [ -w "$DEX_BIN_DIR" ] || error_perms "\$DEX_BIN_DIR $DEX_BIN_DIR is not writable"

  local namespace="$DEX_NAMESPACE-install"

  if $__pull_flag; then
    dex-detect-imgstr $__imgstr || error "lookup failed to parse $__imgstr"
    $__pull_flag && dex-source-pull "$__source_match"
  fi

  dex-image-build $namespace || error_exception \
    "failed to build any images matching $__imgstr"

  log "* installing $__source_match/$__image_match images..."

  for imgname in ${__built_images[@]}; do

    local api=$(__local_docker inspect --type image --format "{{ index .Config.Labels \"org.dockerland.dex.api\" }}" $imgname)
    local image=$(__local_docker inspect --type image --format "{{ index .Config.Labels \"org.dockerland.dex.image\" }}" $imgname)
    local tag=$(__local_docker inspect --type image --format "{{ index .Config.Labels \"org.dockerland.dex.build-tag\" }}" $imgname)
    local bin="$DEX_BIN_DIR/${DEX_BIN_PREFIX}${image}-${tag}"
    local runtimeFn="$api-runtime"

    if [ -z "$api" ]; then
      log "skipping $imgname -- org.dockerland.dex.api label not provided"
      continue
    elif [ ! "$(type -t $runtimeFn)" = "function" ]; then
      log "skipping $imgname -- missing api runtime function ($runtimeFn)"
      continue
    elif [ -z "$image" ]; then
      log "skipping $imgname -- org.dockerland.dex.image label not provided"
      continue
    elif [ -z "$tag" ]; then
      log "skipping $imgname -- org.dockerland.dex.build-tag label not provided"
      continue
    else
      $__force_flag && rm -rf $bin

      if [ -e $bin ]; then
        log \
          "! $bin exists" \
          "  skipping $image installation" \
          "  use --force to overwrite"
      else
        echo "#!/usr/bin/env bash" > $bin
        declare -f __local_docker >> $bin
        declare -f __deactivate_machine >> $bin
        declare -f dex-image-build-container >> $bin
        declare -f docker_safe_name >> $bin
        declare -f get_group_id >> $bin
        declare -f $runtimeFn >> $bin
        echo "__image=\"$imgname\"" >> $bin
        echo "$runtimeFn \$@" >> $bin
        chmod +x $bin || error_exception "unable to mark $bin executable"
        log "+ installed $(basename $bin)"

        dex-install-link $bin ${DEX_BIN_PREFIX}${image} || \
          error_exception "unable to create link to $bin"
      fi
    fi

    if $__global_flag ; then
      dex-install-link $bin $image || \
        error_exception "unable to create global link to $bin"
    fi
  done
}

# dex-install-link <src> <dest>
dex-install-link(){
  [ -e $1 ] || error_exception "install-link: source $1 does not exist"
  local __src_dir=$(dirname $1)
  local __src_file=$(basename $1)
  (
    cd $__src_dir || exit 1

    $__force_flag && rm -rf $2

    if [ -e $2 ] || [ -L $2 ]; then
      log \
        "! $__src_dir/$2 exists" \
        "  skipped linking $2 to $__src_file" \
        "  use --force to overwrite"
    else
      ln -s $__src_file $2 || exit 1
      log "+ linked $__src_dir/$2 to $__src_file"
    fi
  )
  return $?
}
#
# lib.d/dex-run.sh for dex -*- shell-script -*-
#

dex-run(){

  [ -z "$__imgstr" ] && error_exception \
    "dex-run requires an [repository/]<image>[:tag] imgstr"

  dex-detect-imgstr $__imgstr || error "lookup failed to parse $__imgstr"
  __image="$DEX_NAMESPACE/$__image_match:$__image_tag"

  #@TODO test special errcode for wildcard handling
  [[ $__image == *"*"* ]] && error "dex-run does not allow wildcards"

  # build image if it is missing
  image_api=$(__local_docker inspect --type image --format "{{ index .Config.Labels \"org.dockerland.dex.api\" }}" $__image)
  if [ $? -ne 0 ] || $__build_flag ; then
    $__pull_flag && dex-source-pull "$__source_match"
    dex-image-build || error \
      "unable to build $__image" \
      "is $__image_match:$__image_tag provided by a source?"

  else
    [ -z "$image_api" ] && error \
      "the $__image image is missing a org.dockerland.dex.api label" \
      "please ensure you're up to date, rebuild it, or consult image maintainer"

    [ "$image_api" = "$DEX_RUNTIME" ] || log \
      "warning, the $__image image is labeled for a different api." \
      "please ensure you're up to date, rebuild it, or consult image maintainer" \
      "current api: $DEX_RUNTIME" \
      "$__image api: $image_api"
  fi

  # __image is built and ready
  v1-runtime $@
  return $?
}
#
# lib.d/dex-remote.sh for dex -*- shell-script -*-
#

dex-source-add(){

  { [ -z "$__lookup_name" ] || [ -z "$__lookup_url" ]; } && error_exception \
    error "source-add requires NAME and URL"

  if $__force_flag; then
    dex-source-rm "$__lookup_name"
    dex-source-rm "$__lookup_url"
  elif dex-detect-sourcestr "$__lookup_name" || dex-detect-sourcestr "$__lookup_url" ; then
    error_exception "refusing to add $__lookup_name -- duplicate name or url"
  fi

  [ -e $DEX_HOME/checkouts/$__lookup_name ] && error_exception \
    "refusing to add $__lookup_name" \
    "checkout $DEX_HOME/checkouts/$__lookup_name already exists" \
    "use --force flag to overwrite"

  clone_or_pull "$__lookup_url" "$DEX_HOME/checkouts/$__lookup_name" || error \
    "unable to add respository"

  echo "$__lookup_name $__lookup_url" >> $DEX_HOME/sources.list || error \
    "unable to update sources.list"

  log "$__lookup_name added"
}

dex-source-ls(){
  [ ! -e $DEX_HOME/sources.list ] && error_noent \
    "missing $DEX_HOME/sources.list"

  cat $DEX_HOME/sources.list |
  while read __source_name __source_url junk ; do

    # skip blank, malformed, or comment lines
    if [ -z "$__source_name" ] || [ -z "$__source_url" ] || [[ $__source_name = \#* ]]; then
      continue
    fi

    printf "$__source_name $__source_url\n"
  done
}

# dex-source-pull updates a source checkout. updates all sources if * is passed.
# usage: dex-source-pull <repostr|*>
#    ex: dex-source-pull core
#    ex: dex-source-pull git@github.com:dockerland/dex-dockerfiles-core.git
#    ex: dex-remote pull *
dex-source-pull(){
  [ -z "$1" ] || __sourcestr="$1"

  [ -z "$__sourcestr" ] && error_exception \
    "source-pull requires a repository name or URL"

  dex-detect-sourcestr "$__sourcestr" || {
    [ -z "$1" ] && error "no match for $__sourcestr in sources.list"
    log "$__sourcestr not found, skipping pull..."
    return 1
  }

  for __source in "${__sources[@]}"; do
    read -r __source_name __source_url <<< "$__source"

    if ! $__force_flag && is_dirty $__checkouts/$__source_name ]; then
      error "$DEX_HOME/checkouts/$__source_name has local changes" \
      "pass --force to force update, or reset/upstream your changes"
    fi

    ! $DEX_NETWORK && [[ ! "$__source_url" == /* ]] && {
      log "skipping $__source_name -- networking disabled"
      continue
    }


    clone_or_pull $__source_url $__checkouts/$__source_name $__force_flag || \
      error "error pulling $__source_name"

    log "$__source_name updated"
  done
}


dex-source-rm(){
  [ -z "$1" ] || __sourcestr=$1

  [ -z "$__sourcestr" ] && error_exception \
    "source-rm requires a repository name or URL"

  dex-detect-sourcestr "$__sourcestr" || {
    [ -z "$1" ] && error "no match for $__sourcestr in sources.list"
    log "$__sourcestr not found, skipping removal..."
    return 1
  }

  for __source in "${__sources[@]}"; do
    read -r __source_name __source_url <<< "$__source"

    if $__force_flag; then
      rm -rf $DEX_HOME/checkouts/$__source_name 2>/dev/null
    elif [ -d $DEX_HOME/checkouts/$__source_name ]; then

      [ ! -w $DEX_HOME/checkouts/$__source_name  ] && error_perms \
        "$DEX_HOME/checkouts/$__source_name" is not writable

      is_dirty $DEX_HOME/checkouts/$__source_name ] && error \
        "$DEX_HOME/checkouts/$__source_name has local changes" \
        "pass --force to force removal, or reset/upstream your changes"

      rm -rf $DEX_HOME/checkouts/$__source_name
    fi

    sed_inplace $DEX_HOME/sources.list "/$__source_name /d"
    log "removed $__source_name"

  done
}
#
# lib.d/dex-vars.sh for dex -*- shell-script -*-
#

dex-vars-print(){
  while [ $# -ne 0 ]; do
    eval "printf \"$1=\$$1\n\""
    shift
  done
}


dex-vars-reset(){
  for var in "${DEX_VARS[@]}"; do
    unset $var
  done
}


dex-vars-init(){
  while [ $# -ne 0 ]; do
    case $1 in
      DEX_BIN_DIR) eval "$1=\${$1:-/usr/local/bin}" ;;
      DEX_BIN_PREFIX) eval "$1=\${$1:-d}" ;;
      DEX_HOME) eval "$1=\${$1:-~/.dex}" ;;
      DEX_NAMESPACE) eval "$1=\${$1:-dex/\$DEX_RUNTIME}" ;;
      DEX_NETWORK) eval "$1=\${$1:-true}" ;;
      DEX_RUNTIME) eval "$1=\${$1:-v1}" ;;
      *) error_exception "$1 has no default configuration value" ;;
    esac
    shift
  done

  # bootstrap internal vars
  __checkouts=$DEX_HOME/checkouts
}


dex-vars-shellprint(){
  # @TODO -- shell detection for fish|export
  while [ $# -ne 0 ]; do
    eval "printf \"export $1=\$$1\n\""
    shift
  done

  printf "# Run this command to configure your shell: \n"
  printf "# eval \$($__entrypoint)\n\n"
}
# usage: dex-fetch <url> <target-path>
dex-fetch(){

  ! $DEX_NETWORK && \
    log "refused to fetch $2 from $1" "networking disabled" && \
    return 1

  fetch-url $1 $2
}

dex-init(){

  [ -d $DEX_HOME ] || mkdir -p $DEX_HOME || error_perms \
    "could not create working directory \$DEX_HOME"

  [ -d $DEX_HOME/checkouts ] || mkdir -p $DEX_HOME/checkouts || error_perms \
    "could not create checkout directory under \$DEX_HOME"

  ( type docker >/dev/null 2>&1 ) || error_noent \
    "dex requires docker"

  [ -e $DEX_HOME/sources.list ] || dex-init-sources

  for path in $DEX_HOME $DEX_HOME/checkouts $DEX_HOME/sources.list; do
    [ -w $path ] || error_perms "$path is not writable"
  done

  return 0
}

dex-init-sources(){
  rm -rf $DEX_HOME/sources.list.fetched &>/dev/null

  if [ ! -e $DEX_HOME/sources.list ]; then
    if dex-fetch "https://raw.githubusercontent.com/dockerland/dex/master/sources.list" $DEX_HOME/sources.list.fetched ; then
      cat $DEX_HOME/sources.list.fetched > $DEX_HOME/sources.list || error_perms \
        "error writing sources.list from fetched file"
    else
      dex-sources-cat > $DEX_HOME/sources.list || error_perms \
        "error creating $DEX_HOME/sources.list"
    fi
  fi
}

dex-sources-cat(){
  cat <<-EOF
#
# dex sources.list
#

core git@github.com:dockerland/dex-dockerfiles-core.git
extra git@github.com:dockerland/dex-dockerfiles-extra.git

EOF
}
#
# lib.d/helpers/cli.sh for dex -*- shell-script -*-
#

# normalize_flags - normalize POSIX short and long flags for easier parsing
# usage: normalize_flags <fargs> [<flags>...]
#   <fargs>: string of short flags requiring an argument.
#   <flags>: flag string(s) to normalize, typically passed as "$@"
# examples:
#   normalize_flags "" "-abc"
#     => -a -b -c
#   normalize_flags "om" "-abcooutput.txt" "--def=jam" "-mz"
#     => -a -b -c -o output.txt --def jam -m z"
#   normalize_flags "om" "-abcooutput.txt" "--def=jam" "-mz" "--" "-abcx" "-my"
#     => -a -b -c -o output.txt --def jam -m z -- -abcx -my"
normalize_flags(){
  local fargs="$1"
  local passthru=false
  local output=""
  shift
  for arg in $@; do
    if $passthru; then
      output+=" $arg"
    elif [ "--" = "$arg" ]; then
      passthru=true
      output+=" --"
    elif [ "--" = ${arg:0:2} ]; then
      output+=" ${arg%=*}"
      [[ "$arg" == *"="* ]] && output+=" ${arg#*=}"
    elif [ "-" = ${arg:0:1} ]; then
      local p=1
      while ((p++)); read -n1 flag; do
        [ -z "$flag" ] || output+=" -$flag"
        if [[ "$fargs" == *"$flag"* ]]; then
          output+=" ${arg:$p}"
          break
        fi
      done < <(echo -n "${arg:1}")
    else
      output+=" $arg"
    fi
  done
  printf "%s" "${output:1}"
}

# normalize_flags_first - like normalize_flags, but outputs flags first.
# usage: normalize_flags <fargs> [<flags>...]
#   <fargs>: string of short flags requiring an argument.
#   <flags>: flag string(s) to normalize, typically passed as "$@"
# examples:
#   normalize_flags_first "" "-abc command -xyz otro"
#     => -a -b -c -x -y -z command otro
#   normalize_flags_first "" "-abc command -xyz otro -- -def xyz"
#     => -a -b -c -x -y -z command otro -- -def xyz

normalize_flags_first(){
  local fargs="$1"
  local output=""
  local cmdstr=""
  local passthru=false
  shift
  for arg in $(normalize_flags "$fargs" "$@"); do
    [ "--" = "$arg" ] && passthru=true
    if $passthru || [ ! "-" = ${arg:0:1} ]; then
      cmdstr+=" $arg"
      continue
    fi
    output+=" $arg"
  done
  printf "%s%s" "${output:1}" "$cmdstr"
}

# set_cmd: loops through a list of commands, prefering the "prefixed" version(s)
#   sets `__cmd` to first-found matching command. uses __cmd_prefix
#   returns 1 if no suitable command found.
set_cmd(){
  __cmd=
  local path=
  for lookup in $@; do
    type ${__cmd_prefix}${lookup} &>/dev/null && {
      __cmd=${__cmd_prefix}${lookup}
      return 0
    }
  done

  for lookup in $@; do
    type $lookup &>/dev/null && {
      __cmd=$lookup
      return 0
    }
  done

  return 1
}

runfunc(){
  [ "$(type -t $1)" = "function" ] || error \
    "$1 is not a valid runfunc target"

  eval "$@"
}

unrecognized_flag(){
  printf "\n\n$1 is an unrecognized flag\n\n"
  display_help 2
}

unrecognized_arg(){

  if [ $__cmd = "main" ]; then
    printf "\n\n$1 is an unrecognized command\n\n"
  else
    printf "\n\n$1 is an unrecognized argument\n\n"
  fi

  display_help 2
}

# get_group_id accepts <group_name> and outputs group id, empty if not found.
get_group_id(){
  if type getent &>/dev/null; then
    getent group $1 | cut -d: -f3
  elif type dscl &>/dev/null; then
    dscl . -read /Groups/$1 PrimaryGroupID 2>/dev/null | awk '{ print $2 }'
  else
    python -c "import grp; print(grp.getgrnam(\"$1\").gr_gid)" 2>/dev/null
  fi
}


# sed_inplace : in place file substitution
############################################
#
# usage: sed_inplace "file" "sed regex pattern"
#    ex: sed_inplace "/tmp/file" "s/CLIENT_CODE/ACME/g"
#    ex: sed_inplace "/tmp/file" "/pattern_to_remove/d"
#
sed_inplace(){
  local sed=
  local sed_flags="-r -i"

  for sed in gsed /usr/local/bin/sed sed; do
    type $sed &>/dev/null && break
  done

  [ "$sed" = "sed" ] && [[ "$OSTYPE" =~ darwin|macos* ]] && sed_flags="-i '' -E"
  $sed $sed_flags "$2" $1
}
__local_docker(){
  (
    __deactivate_machine
    exec docker "$@"
  )
}

__local_docker_compose(){
  (
    __deactivate_machine
    exec docker-compose "$@"
  )
}

__deactivate_machine(){
  # @TODO support boot2docker / concept of "default" machine
  type docker-machine &>/dev/null && {
    eval $(docker-machine env --unset --shell bash)
    return
  }
  # lets be safe and unset if missing docker-machine
  unset DOCKER_HOST DOCKER_TLS_VERIFY DOCKER_CERT_PATH DOCKER_MACHINE_NAME
}

docker_safe_name(){
  local name="$@"
  set -- "${name:0:1}" "${name:1}"
  printf "%s%s" "${1//[^a-zA-Z0-9]/0}" "${2//[^a-zA-Z0-9_.-]/_}"
}
#
# lib.d/helpers/git.sh for dex -*- shell-script -*-
#

# usage: clone_or_pull <repo-path-or-url> <destination> <force boolean>
clone_or_pull(){
  local force=${3:-false}
  if [ -d $2 ]; then
    # pull
    (
      cd $2
      $force && git reset --hard HEAD
      git pull
    ) || {
      log "error pulling changes from git"
      return 1
    }
  else
    # clone

    #@TODO support reference repository
    #  [detect if local repo is a bare repo -- but how to find remote?]

    local SHARED_FLAG=

    [ -w $(dirname $2) ] || {
      log "destination directory not writable"
      return 126
    }

    if [[ $1 == /* ]]; then
      # perform a shared clone (URL is a local path starting with '/...' )
      [ -d $1/.git ] || {
        log "$1 is not a path to a local git repository"
        return 1
      }
      SHARED_FLAG="--shared"
    fi

    git clone $SHARED_FLAG $1 $2 || {
      log "error cloning $1 to $2"
      return 1
    }
  fi

  return 0
}


# checks git working copy.
# return 1 if clean (not dirty), 0 if dirty (changes exist)
is_dirty(){

  [ -d $1/.git ] || {
    log "$1 is not a git repository. continuing..."
    return 1
  }

  (
    set -e
    cd $1
    [ ! -z "$(git status -uno --porcelain)" ]
  )
  return $?
}
#
# lib.d/helpers/git.sh for dex -*- shell-script -*-
#

error(){
  [ -z "$1" ] && set -- "general exception. halting..."

  printf "\e[31m%b\n\e[0m" "$@" >&2
  exit ${__error_code:-1}
}

error_noent() {
  __error_code=127
  error "$@"
}

error_perms() {
  __error_code=126
  error "$@"
}

error_exception() {
  __error_code=2
  error "$@"
}


log(){
  printf "\e[33m%b\n\e[0m" "$@" >&2
}

warn(){
  printf "\e[35m%b\n\e[0m" "$@" >&2
}

# prompt_echo - helper for assigning variable values
# usage: prompt_echo <prompt> [default fallback]
# example: 
#   name=$(prompt_echo "name to encrypt")
#   port=$(prompt_echo "port [8080]" 8080)

prompt_echo() {
  while true; do
    # read always from /dev/tty, use `if [ -t 0 ]` upstream to avoid prompt
    read -r -p "  ${1:-input} : " INPUT </dev/tty
    [ -z "$INPUT" ] || { echo "$INPUT" ; return 0 ; }
    [ -z "$2" ] || { echo "$2" ; return 0 ; }
    
    printf "  \033[31m%s\033[0m\n" "invalid input" >&2
  done
}

prompt_confirm() {
  while true; do
    echo
    # read always from /dev/tty, use `if [ -t 0 ]` upstream to avoid prompt
    read -r -n 1 -p "  ${1:-Continue?} [y/n]: " REPLY </dev/tty
    case $REPLY in
      [yY]) echo ; return 0 ;;
      [nN]) echo ; return 1 ;;
      *) printf "  \033[31m%s\033[0m\n" "invalid input" >&2
    esac
  done
}

# line_in_file : ensure a line exists in a file
###############################################
#
# usage: line_in_file "file" "match" "line"
#    ex: line_in_file "varsfile" "^VARNAME=.*$" "VARNAME=value"
#
line_in_file(){
  local delim=${4:-"|"}
  grep -q "$2" $1 2>/dev/null && sed_inplace $1 "s$delim$2$delim$3$delim" || echo $3 >> $1
}
#
# lib.d/helpers/network.sh for dex -*- shell-script -*-
#

# usage: fetch-url <url> <target-path>
fetch-url(){
  local WGET_PATH=${WGET_PATH:-wget}
  local CURL_PATH=${CURL_PATH:-curl}

  if ( type $WGET_PATH &>/dev/null ); then
    $WGET_PATH $1 -qO $2 || ( rm -rf $2 ; exit 1 )
  elif ( type $CURL_PATH &>/dev/null ); then
    $CURL_PATH -Lfso $2 $1
  else
    log "failed to fetch $2 from $1" "missing both curl and wget"
    return 2
  fi

  [ $? -eq 0 ] && return 0

  log "failed to fetch $2 from $1"
  return 126
}

# shell_detect - detect user's shell and sets
#  __shell (user's shell, e.g. 'fish', 'bash', 'zsh')
#  __shell_file (shell configuration file, e.g. '~/.bashrc')
# usage: shell_detect [shell (skips autodetect)]
shell_detect(){
  # https://github.com/rbenv/rbenv/wiki/Unix-shell-initialization
  __shell=${1:-$(basename $SHELL | awk '{print tolower($0)}')}
  __shell_file=

  local search=
  case $__shell in
    bash|sh   ) search=".bashrc .bash_profile" ;;
    cmd       ) search=".profile" ;;
    ash|dash  ) search=".profile" ;;
    fish      ) search=".config/fish/config.fish" ;;
    ksh       ) search=".kshrc" ;;
    powershell) search=".profile" ;;
    tcsh      ) search=".tcshrc .cshrc .login" ;;
    zsh       ) search=".zshenv .zprofile .zshrc" ;;
    *         ) error_exception "unrecognized shell \"$__shell\"" ;;
  esac

  for file in $search; do
    [ -e ~/$file ] && {
      __shell_file=~/$file
      return 0
    }
  done

  __shell_file=~/.profile
  echo "# failed to detect shell config file, falling back to $__shell_file"
  return 1
}

# shell_eval_export - print evaluable commands to export a variable
# usage: shell_eval_export <variable> <value> [append_flag] [append_delim]
shell_eval_export(){
  local append=${3:-false}
  local append_delim=$4
  [ "$1" = "PATH" ] && [ -z "$append_delim" ] && append_delim=':'

  if $append; then
    case $__shell in
      cmd       ) echo "SET $1=%${1}%${append_delim}${2}" ;;
      fish      ) echo "set -gx $1 \$${1} ${2};" ;;
      tcsh      ) echo "setenv $1 = \$${1}${append_delim}${2}" ;;
      powershell) echo "\$Env:$1 = \"\$${1}${append_delim}${2}\";" ;;
      *         ) echo "export $1=\"\$${1}${append_delim}${2}\"" ;;
    esac
  else
    case $__shell in
      cmd       ) echo "SET $1=$2" ;;
      fish      ) echo "set -gx $1 \"$2\";" ;;
      tcsh      ) echo "setenv $1 \"$2\"" ;;
      powershell) echo "\$Env:$1 = \"$2\";" ;;
      *         ) echo "export $1=\"$2\"" ;;
    esac
  fi

  shell_eval_message
}

shell_eval_message(){
  #@TODO transform entrypoint to absolute path

  local pre
  local post

  case $__shell in
    cmd       ) pre="@FOR /f "tokens=*" %i IN ('" post="') DO @%i'" ;;
    fish      ) pre="eval (" post=")" ;;
    tcsh      ) pre="eval \`" post="\`" ;;
    powershell) pre="&" post=" | Invoke-Expression" ;;
    *         ) pre="eval \$(" ; post=")" ;;
  esac

  echo "# To configure your shell, run:"
  echo "#   ${pre}${__entrypoint}${post}"
  echo "# To remember your configuration in subsequent shells, run:"
  echo "#   echo ${pre}${__entrypoint}${post} >> $__shell_file"
}
#
# lib.d/main_image.sh for dex -*- shell-script -*-
#

#@TODO implement package building (in repositories as well -- symlink strategy)
#@TODO implement --pull to update sources
#@TODO fix argparsing, build only accepts a single argument

main_image(){
  local operand="display_help"
  local operand_args=

  __force_flag=false
  __skip_namespace=false
  QUIET_FLAG=

  if [ $# -eq 0 ]; then
    display_help 2
  else
    set -- $(normalize_flags_first "" "$@")
    while [ $# -ne 0 ]; do
      case $1 in
        -f|--force)       __force_flag=true ;;
        -h|--help)        display_help ;;
        -q|--quiet)       QUIET_FLAG="-q" ;;
        -a|--all)         __skip_namespace=true ;;
        --)               shift ; operand_args="$@" ; break ;;
        -*)               unrecognized_flag $1 ;;
        build|rm|ls)      operand="dex-image-$1"
                          __imgstr=$2
                          shift
                          ;;
        *)                unrecognized_arg "$1" ;;
      esac
      shift
    done
  fi

  dex-init
  $operand $operand_args
  exit $?

}
#
# lib.d/main_install.sh for dex -*- shell-script -*-
#

main_install(){
  local operand="display_help"
  local operand_args=

  __force_flag=false
  __global_flag=false
  __pull_flag=false

  if [ $# -eq 0 ]; then
    display_help 2
  else
    set -- $(normalize_flags_first "" "$@")
    while [ $# -ne 0 ]; do
      case $1 in
        -f|--force)       __force_flag=true ;;
        -g|--global)      __global_flag=true ;;
        -p|--pull)        __pull_flag=true ;;
        -h|--help)        display_help ;;
        --)               shift ; operand_args="$@" ; break ;;
        -*)               unrecognized_flag $1 ;;
        *)                operand="dex-install"
                          __imgstr=$1
                          ;;
      esac
      shift
    done
  fi

  $operand $operand_args
  exit $?
}
#
# lib.d/main_run.sh for dex -*- shell-script -*-
#

main_run(){
  local operand="display_help"
  local operand_args=

  # defaults
  __build_flag=false
  __pull_flag=false
  __interactive_flag=false
  __persist_flag=false

  if [ $# -eq 0 ]; then
    display_help 2
  else
    while [ $# -ne 0 ]; do
      case $1 in
        -b|--build)     __build_flag=true ;;
        -p|--pull)      __build_flag=true ; __pull_flag=true ;;
        -i|-t|-it|--interactive) __interactive_flag=true ;;
        -h|--help)      display_help ;;
        --cmd)          DEX_DOCKER_CMD="$2" ; shift ;;
        --entrypoint)   DEX_DOCKER_ENTRYPOINT="$2" ; shift ;;
        --home)         DEX_DOCKER_HOME="$2" ; shift ;;
        --log-driver)   DEX_DOCKER_LOG_DRIVER="$2" ; shift ;;
        --persist)      __persist_flag=true ;;
        --gid|--group)  DEX_DOCKER_GID="$2" ; shift ;;
        --uid|--user)   DEX_DOCKER_UID="$2" ; shift ;;
        --workspace)    DEX_DOCKER_WORKSPACE="$2" ; shift ;;
        --)             shift ; operand_args="$@" ; break ;;
        -*)             unrecognized_flag $1 ;;
        *)              __imgstr="$1"
                        shift
                        operand="dex-run"
                        operand_args="$@"
                        break ;;
      esac
      shift
    done
  fi

  dex-init
  $operand $operand_args
  exit $?
}
#!/usr/bin/env bash

v1-runtime(){
  DEX_HOME=${DEX_HOME:-~/.dex}
  [ -z "$__image" ] && { echo "missing runtime image" ; exit 1 ; }
  IFS=":" read -r __name __tag <<< "$__image"

  read -d "\n" DEX_HOST_UID DEX_HOST_GID DEX_HOST_USER DEX_HOST_GROUP DEX_HOST_PWD DEX_IMAGE_NAME < <(
    exec 2>/dev/null ; id -u ; id -g ; id -un ; id -gn ; pwd ; basename $__name )

  # label defaults -- images may provide a org.dockerland.dex.<var> label
  #  supplying a value that overrides these default values, examples are:
  #
  #  org.dockerland.dex.docker_devices=/dev/shm   (shm mounted as /dev/shm)
  #  org.dockerland.dex.docker_envars="LANG TERM !MYAPP_" (passthru LANG & TERM & MYAPP_*)
  #  org.dockerland.dex.docker_flags=-it          (interactive tty)
  #  org.dockerland.dex.docker_groups=tty         (adds 'tty' to container user)
  #  org.dockerland.dex.docker_home=~             (user's actual home)
  #  org.dockerland.dex.docker_volumes=/etc/hosts:/etc/hosts:ro
  #  org.dockerland.dex.docker_workspace=/        (host root as /dex/workspace)
  #  org.dockerland.dex.host_docker=rw            (expose host's docker socket and passthru docker vars)
  #  org.dockerland.dex.host_paths=rw             (rw mount host HOME and CWD)
  #  org.dockerland.dex.host_users=ro             (augment container's /etc/passwd and /etc/group files [in read-only mode] with current host's uid|gid)
  #  org.dockerland.dex.window=yes                (applies window/X11 flags)
  #
  __docker_devices=
  __docker_envars="LANG TZ"
  __docker_flags=
  __docker_groups=
  __docker_home=$DEX_IMAGE_NAME-$__tag
  __docker_workspace=$DEX_HOST_PWD
  __docker_volumes=
  __host_docker=
  __host_paths="ro"
  __host_users=

  __window=

  # augment defaults with image meta
  for label in api docker_devices docker_envars docker_flags docker_groups docker_home docker_workspace docker_volumes host_docker host_paths host_users window ; do
    # @TODO reduce this to a single docker inspect command
    val=$(__local_docker inspect --type image --format "{{ index .Config.Labels \"org.dockerland.dex.$label\" }}" $__image)
    [ -z "$val" ] && continue
    eval "__$label=\"$val\""
  done

  ${__interactive_flag:-false} && __docker_flags+=" --tty --interactive"
  ${__persist_flag:-false} || __docker_flags+=" --rm"

  # rutime defaults -- override these by passing run flags, or through
  # exporting the following vars:
  #
  # DEX_DOCKER_CMD - alternative command passed to docker run
  # DEX_DOCKER_ENTRYPOINT - alternative entrypoint passed to docker run
  #
  # DEX_DOCKER_HOME - host directory mounted as the container's $HOME
  # DEX_DOCKER_WORKSPACE - host directory mounted as the container's CWD
  #
  # DEX_DOCKER_GID - gid to run the container under
  # DEX_DOCKER_UID - uid to run the container under
  #
  # DEX_DOCKER_LOG_DRIVER - docker logging driver
  # DEX_WINDOW_FLAGS - flags applied to windowed/X11 images
  #
  DEX_DOCKER_CMD=${DEX_DOCKER_CMD:-}
  DEX_DOCKER_ENTRYPOINT=${DEX_DOCKER_ENTRYPOINT:-}

  DEX_DOCKER_HOME=${DEX_DOCKER_HOME:-$__docker_home}
  DEX_DOCKER_HOME=${DEX_DOCKER_HOME/#\~/$HOME}
  DEX_DOCKER_WORKSPACE=${DEX_DOCKER_WORKSPACE:-$__docker_workspace}

  DEX_DOCKER_GID=${DEX_DOCKER_GID:-$DEX_HOST_GID}
  DEX_DOCKER_UID=${DEX_DOCKER_UID:-$DEX_HOST_UID}

  DEX_DOCKER_LOG_DRIVER=${DEX_DOCKER_LOG_DRIVER:-'none'}
  DEX_WINDOW_FLAGS=${DEX_WINDOW_FLAGS:-"-v /tmp/.X11-unix:/tmp/.X11-unix -e DISPLAY=unix$DISPLAY"}

  [ -z "$__api" ] && \
    { echo "$__image did not specify an org.dockerland.dex.api label!" ; exit 1 ; }

  # if home is not an absolute path, make relative to $DEX_HOME/homes/
  [ "${DEX_DOCKER_HOME:0:1}" != '/' ] && \
    DEX_DOCKER_HOME=$DEX_HOME/homes/$DEX_DOCKER_HOME

  [ -d "$DEX_DOCKER_HOME" ] || mkdir -p $DEX_DOCKER_HOME || \
    { echo "unable to stub home directory: $DEX_DOCKER_HOME" ; exit 1 ; }

  [ -d "$DEX_DOCKER_WORKSPACE" ] || \
    { echo "workspace is not a directory: $DEX_DOCKER_WORKSPACE" ; exit 1 ; }

  [ -z "$DEX_DOCKER_ENTRYPOINT" ] || \
    __docker_flags+=" --entrypoint=$DEX_DOCKER_ENTRYPOINT"

  # piping to|from a container requires interactive, non-tty input
  if [ ! -t 1 ] || ! tty -s > /dev/null 2>&1 ; then
    __docker_flags+=" --interactive=true --tty=false"
  fi

  # apply windowing vars (if window=true)
  case $(echo "$__window" | awk '{print tolower($0)}') in true|yes|on)
      __docker_flags+=" $DEX_WINDOW_FLAGS -e DEX_WINDOW=true"
      __docker_groups+=" audio video"
      __docker_devices+=" dri snd video video0"
      __docker_volumes+=" /dev/shm /var/lib/dbus/machine-id:/var/lib/dbus/machine-id:ro /etc/machine-id:/etc/machine-id:ro"

      # @TODO bats testing
      [ -z "$XDG_RUNTIME_DIR" ] || {
        __docker_flags+=" -v $XDG_RUNTIME_DIR:/var/run/xdg -e XDG_RUNTIME_DIR=/var/run/xdg"
      }

      # append xauth
      # @TODO test under fedora, opensuse, ubuntu
      # @TODO bats testing
      type xauth &>/dev/null && {
        __xauth=$DEX_HOME/.xauth
        touch $__xauth && \
          xauth nlist $DISPLAY | sed -e 's/^..../ffff/' | xauth -f $__xauth nmerge - &>/dev/null && \
          __docker_flags+=" -v $__xauth:/tmp/.xauth -e XAUTHORITY=/tmp/.xauth"
      }

      # lookup CONFIG_USER_NS (e.g. for chrome sandbox),
      #   and add SYS_ADMIN cap if missing
      type zgrep &>/dev/null && {
        zgrep CONFIG_USER_NS=y /proc/config.gz &>/dev/null || \
          __docker_flags+=" --cap-add=SYS_ADMIN"
      }
      ;;
  esac

  # mount typical host paths to coax common absolute path resolutions
  case $(echo "$__host_paths" | awk '{print tolower($0)}') in rw|ro)
    if [[ ! "$HOME" =~ ^($DEX_HOST_PWD|/dex/home)$ ]]; then
      __docker_volumes+=" $HOME:$HOME:$__host_paths"
    fi
    if [[ ! "$DEX_HOST_PWD" =~ ^($HOME|/dex/workspace|/|/bin|/dev|/etc|/lib|/lib64|/opt|/proc|/sbin|/run|/sbin|/srv|/sys|/usr|/var)$ ]]; then
      __docker_volumes+=" $DEX_HOST_PWD:$DEX_HOST_PWD:$__host_paths"
    fi
  esac

  # map host /etc/passwd and /etc/group in container
  case $(echo "$__host_users" | awk '{print tolower($0)}') in rw|ro)
    container_sha=$(dex-image-build-container $__image) || {
      echo "dex runtime failed to spawn a build container"
      exit 1
    }
    container_dir=$DEX_HOME/build-containers/$container_sha
    [ -d $container_dir ] || mkdir -p $container_dir
    [ -e $container_dir/passwd ] || __local_docker cp $container_sha:/etc/passwd $container_dir/passwd
    [ -e $container_dir/group ] || __local_docker cp $container_sha:/etc/group $container_dir/group

    # augment /etc/passwd and /etc/group files with current user (if !already exists)
    grep -q ":$DEX_HOST_UID:$DEX_HOST_GID:" $container_dir/passwd || \
      echo "$DEX_HOST_USER:x:$DEX_HOST_UID:$DEX_HOST_UID:gecos:/dex/home:/bin/sh" >> $container_dir/passwd
    grep -q ":$DEX_HOST_GID:" $container_dir/group || \
      echo "$DEX_HOST_GROUP:x:$DEX_HOST_GID:" >> $container_dir/group

    __docker_volumes+=" $container_dir/passwd:/etc/passwd:$__host_users $container_dir/group:/etc/group:$__host_users"
  esac

  # map host docker socket and passthru docker vars
  case $(echo "$__host_docker" | awk '{print tolower($0)}') in rw|ro)
    __docker_socket=${DOCKER_SOCKET:-/var/run/docker.sock}
    [ -S $__docker_socket ] || {
      echo "image requests docker, but $__docker_socket is not a valid socket"
      exit 1
    }
    __docker_volumes+=" $__docker_socket:/var/run/docker.sock:$__host_docker $DOCKER_CERT_PATH $MACHINE_STORAGE_PATH"
    __docker_flags+=" --group-add=$(ls -ln $__docker_socket | awk '{print $4}')"
    __docker_envars+=" DOCKER_* MACHINE_STORAGE_PATH"
  esac

  # mount specicified devices (only if they exist)
  for path in $__docker_devices; do
    [ "${path:0:5}" = "/dev/" ] || path="/dev/$path"
    [ -e $path ] && __docker_flags+=" --device=$path"
  done

  # mount specified volumes (only if they exist)
  for path in $__docker_volumes; do
    IFS=":" read path_host path_container path_mode <<< "$path"
    path_host=${path_host/#\~/$HOME}
    [ -e "$path_host" ] || continue
    __docker_flags+=" -v $path_host:${path_container:-$path_host}:${path_mode:-rw}"
  done

  # add specified groups (only if they exist)
  for group in $__docker_groups; do
    gid=$(get_group_id $group)
    [ -z "$gid" ] || __docker_flags+=" --group-add=$gid"
  done

  # assign passthru envars (if empty)
  # @TODO can probably refactor here...
  __vars=""
  for var in $__docker_envars; do
    if [[ $var == *"*" ]]; then
      eval "for var in \${!$var}; do __vars+=\" \$var\" ; done"
    else
      __vars+=" $var"
    fi
  done
  for var in $__vars; do
    eval "[ -z \"\$$var\" ] || __docker_flags+=\" -e $var=\$$var\""
  done

  # deactivate docker-machine
  __deactivate_machine

  ${DEX_DEBUG:=false} && __exec="echo"
  ${__exec:-exec} docker run $__docker_flags \
    -e DEX_DOCKER_HOME=$DEX_DOCKER_HOME \
    -e DEX_DOCKER_WORKSPACE=$DEX_DOCKER_WORKSPACE \
    -e DEX_HOST_GID=$DEX_HOST_GID \
    -e DEX_HOST_GROUP=$DEX_HOST_GROUP \
    -e DEX_HOST_PWD=$DEX_HOST_PWD \
    -e DEX_HOST_UID=$DEX_HOST_UID \
    -e DEX_HOST_USER=$DEX_HOST_USER \
    -e DEX_HOST_HOME=$HOME \
    -e DEX_IMAGE=$__image \
    -e DEX_IMAGE_NAME=$DEX_IMAGE_NAME \
    -e DEX_IMAGE_TAG=$__tag \
    -e HOME=/dex/home \
    -u $DEX_DOCKER_UID:$DEX_DOCKER_GID \
    -v $DEX_DOCKER_HOME:/dex/home \
    -v $DEX_DOCKER_WORKSPACE:/dex/workspace \
    --log-driver=$DEX_DOCKER_LOG_DRIVER \
    --workdir=/dex/workspace \
    $__image $DEX_DOCKER_CMD $@
}
#
# lib.d/main_source.sh for dex -*- shell-script -*-
#

main_source(){
  local operand="display_help"
  local operand_args=

  __force_flag=false

  if [ $# -eq 0 ]; then
    display_help 2
  else
    set -- $(normalize_flags_first "" "$@")
    while [ $# -ne 0 ]; do
      case $1 in
        -f|--force)       __force_flag=true ;;
        -h|--help)        display_help ;;
        --)               shift ; operand_args="$@" ; break ;;
        -*)               unrecognized_flag $1 ;;
        add)              operand="dex-source-add"
                          __lookup_name="$2"
                          __lookup_url="$3"
                          shift 2
                          ;;
        ls|pull)          operand="dex-source-$1"
                          if [ -z "$2" ]; then
                            __sourcestr='*'
                          else
                            __sourcestr="$2"
                            shift
                          fi
                          ;;
        rm)               operand="dex-source-rm"
                          operand_args="$2"
                          shift
                          ;;
        *)                unrecognized_arg "$1" ;;
      esac
      shift
    done
  fi

  dex-init
  $operand $operand_args
  exit $?
}
#
# lib.d/main_uninstall.sh for dex -*- shell-script -*-
#

main_uninstall(){
  local operand="display_help"
  local operand_args=

  if [ $# -eq 0 ]; then
    display_help 2
  else
    set -- $(normalize_flags_first "" "$@")
    while [ $# -ne 0 ]; do
      case $1 in
        -h|--help)         display_help ;;
        --)                shift ; operand_args="$@" ; break ;;
        -*)                unrecognized_flag $1 ;;
        *)                 unrecognized_arg "$1" ;;
      esac
      shift
    done
  fi

  $operand $operand_args
  exit $?

}
#
# lib.d/main_vars.sh for dex -*- shell-script -*-
#

main_vars(){
  local operand="dex-vars-print"
  local operand_args=

  local reset=false
  local vars=()

  if [ $# -eq 0 ]; then
    display_help 2
  else
    set -- $(normalize_flags_first "" "$@")
    while [ $# -ne 0 ]; do
      case $1 in
        all)               vars=( "${DEX_VARS[@]}" ) ;;
        -d|--defaults)     operand="dex-vars-shellprint"
                           dex-vars-reset ;;
        -h|--help)         display_help ;;
        --)                shift ; operand_args="$@" ; break ;;
        -*)                unrecognized_flag $1 ;;
        *)                 vars+=( "$1" ) ;;
      esac
      shift
    done
  fi

  dex-vars-init ${vars[@]}
  $operand $operand_args ${vars[@]}
  exit $?
}
main "$@"
